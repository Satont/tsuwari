package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/samber/lo"
	model "github.com/satont/twir/libs/gomodels"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/gqlmodel"
	timersbusservice "github.com/twirapp/twir/libs/bus-core/timers"
	"gorm.io/gorm"
)

// TimersCreate is the resolver for the timersCreate field.
func (r *mutationResolver) TimersCreate(
	ctx context.Context,
	opts gqlmodel.TimerCreateInput,
) (*gqlmodel.Timer, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	timerId := uuid.NewString()
	entity := model.ChannelsTimers{
		ID:              timerId,
		ChannelID:       dashboardId,
		Name:            opts.Name,
		Enabled:         opts.Enabled,
		TimeInterval:    int32(opts.TimeInterval),
		MessageInterval: int32(opts.MessageInterval),
		Responses: lo.Map(
			opts.Responses,
			func(r gqlmodel.TimerResponseCreateInput, _ int) *model.ChannelsTimersResponses {
				return &model.ChannelsTimersResponses{
					ID:         uuid.NewString(),
					Text:       r.Text,
					IsAnnounce: r.IsAnnounce,
					TimerID:    timerId,
				}
			},
		),
	}

	if err := r.gorm.WithContext(ctx).Create(&entity).Error; err != nil {
		return nil, err
	}

	responses := make([]gqlmodel.TimerResponse, 0, len(entity.Responses))
	for _, response := range entity.Responses {
		responses = append(
			responses,
			gqlmodel.TimerResponse{
				ID:         response.ID,
				Text:       response.Text,
				IsAnnounce: response.IsAnnounce,
			},
		)
	}

	timersReq := timersbusservice.AddOrRemoveTimerRequest{TimerID: entity.ID}
	if entity.Enabled {
		r.twirBus.Timers.AddTimer.Publish(timersReq)
	} else {
		r.twirBus.Timers.RemoveTimer.Publish(timersReq)
	}

	return &gqlmodel.Timer{
		ID:              entity.ID,
		Name:            entity.Name,
		Enabled:         entity.Enabled,
		TimeInterval:    int(entity.TimeInterval),
		MessageInterval: int(entity.MessageInterval),
		Responses:       responses,
	}, nil
}

// TimersUpdate is the resolver for the timersUpdate field.
func (r *mutationResolver) TimersUpdate(
	ctx context.Context,
	id string,
	opts gqlmodel.TimerUpdateInput,
) (*gqlmodel.Timer, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	entity := model.ChannelsTimers{}
	if err := r.gorm.WithContext(ctx).
		Where(`"id" = ? AND "channelId" = ?`, id, dashboardId).
		First(&entity).Error; err != nil {
		return nil, fmt.Errorf("timer not found: %w", err)
	}

	if opts.Name.IsSet() {
		entity.Name = *opts.Name.Value()
	}

	if opts.Enabled.IsSet() {
		entity.Enabled = *opts.Enabled.Value()
	}

	if opts.TimeInterval.IsSet() {
		entity.TimeInterval = int32(*opts.TimeInterval.Value())
	}

	if opts.MessageInterval.IsSet() {
		entity.MessageInterval = int32(*opts.MessageInterval.Value())
	}

	txErr := r.gorm.WithContext(ctx).Transaction(
		func(tx *gorm.DB) error {
			if opts.Responses.IsSet() {
				if err := tx.
					Where(`"timerId" = ?`, entity.ID).
					Delete(&model.ChannelsTimersResponses{}).
					Error; err != nil {
					return err
				}

				entity.Responses = lo.Map(
					opts.Responses.Value(),
					func(r gqlmodel.TimerResponseUpdateInput, _ int) *model.ChannelsTimersResponses {
						return &model.ChannelsTimersResponses{
							ID:         uuid.NewString(),
							Text:       r.Text,
							IsAnnounce: r.IsAnnounce,
							TimerID:    entity.ID,
						}
					},
				)
			}

			if err := r.gorm.WithContext(ctx).Save(&entity).Error; err != nil {
				return err
			}

			return nil
		},
	)

	if txErr != nil {
		return nil, fmt.Errorf("cannot update timer: %w", txErr)
	}

	responses := make([]gqlmodel.TimerResponse, 0, len(entity.Responses))
	for _, response := range entity.Responses {
		responses = append(
			responses,
			gqlmodel.TimerResponse{
				ID:         response.ID,
				Text:       response.Text,
				IsAnnounce: response.IsAnnounce,
			},
		)
	}

	timersReq := timersbusservice.AddOrRemoveTimerRequest{TimerID: entity.ID}
	if entity.Enabled {
		r.twirBus.Timers.AddTimer.Publish(timersReq)
	} else {
		r.twirBus.Timers.RemoveTimer.Publish(timersReq)
	}

	return &gqlmodel.Timer{
		ID:              entity.ID,
		Name:            entity.Name,
		Enabled:         entity.Enabled,
		TimeInterval:    int(entity.TimeInterval),
		MessageInterval: int(entity.MessageInterval),
		Responses:       responses,
	}, nil
}

// TimersRemove is the resolver for the timersRemove field.
func (r *mutationResolver) TimersRemove(ctx context.Context, id string) (bool, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	entity := model.ChannelsTimers{}
	if err := r.gorm.WithContext(ctx).
		Where(`"id" = ? AND "channelId" = ?`, id, dashboardId).
		First(&entity).Error; err != nil {
		return false, fmt.Errorf("timer not found: %w", err)
	}

	if err := r.gorm.WithContext(ctx).Delete(&entity).Error; err != nil {
		return false, err
	}

	r.twirBus.Timers.RemoveTimer.Publish(
		timersbusservice.AddOrRemoveTimerRequest{TimerID: entity.ID},
	)

	return true, nil
}

// Timers is the resolver for the timers field.
func (r *queryResolver) Timers(ctx context.Context) ([]gqlmodel.Timer, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	var entities []model.ChannelsTimers
	if err := r.gorm.WithContext(ctx).
		Where(`"channelId" = ?`, dashboardId).
		Order(`"name" DESC`).
		Preload("Responses").
		Find(&entities).Error; err != nil {
		return nil, err
	}

	timers := make([]gqlmodel.Timer, 0, len(entities))
	for _, entity := range entities {
		responses := make([]gqlmodel.TimerResponse, 0, len(entity.Responses))
		for _, response := range entity.Responses {
			responses = append(
				responses,
				gqlmodel.TimerResponse{
					ID:         response.ID,
					Text:       response.Text,
					IsAnnounce: response.IsAnnounce,
				},
			)
		}

		timers = append(
			timers,
			gqlmodel.Timer{
				ID:              entity.ID,
				Name:            entity.Name,
				Enabled:         entity.Enabled,
				TimeInterval:    int(entity.TimeInterval),
				MessageInterval: int(entity.MessageInterval),
				Responses:       responses,
			},
		)
	}

	return timers, nil
}
