package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"

	"github.com/nicklaw5/helix/v2"
	"github.com/samber/lo"
	model "github.com/satont/twir/libs/gomodels"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/gqlmodel"
	twitchcahe "github.com/twirapp/twir/libs/cache/twitch"
)

// TwirUsers is the resolver for the twirUsers field.
func (r *queryResolver) TwirUsers(
	ctx context.Context,
	opts gqlmodel.TwirUsersSearchParams,
) (*gqlmodel.TwirUsersResponse, error) {
	var page int
	perPage := 50

	if opts.Page.IsSet() {
		page = *opts.Page.Value()
	}

	if opts.PerPage.IsSet() {
		perPage = *opts.PerPage.Value()
	}

	var foundTwitchChannels []helix.Channel
	if opts.Search.IsSet() {
		channels, err := r.cachedTwitchClient.SearchChannels(ctx, *opts.Search.Value())
		if err != nil {
			return nil, err
		}

		foundTwitchChannels = channels
	}

	query := r.gorm.
		WithContext(ctx).
		Order("id DESC").
		Joins("Channel")

	if len(foundTwitchChannels) > 0 {
		var ids []string
		for _, user := range foundTwitchChannels {
			ids = append(ids, user.ID)
		}

		query = query.Where(`"users"."id" IN ?`, ids)
	}

	if opts.IsBotEnabled.IsSet() {
		query = query.Where(`"Channel"."isEnabled" = ?`, *opts.IsBotEnabled.Value())
	}

	if opts.IsBotAdmin.IsSet() {
		query = query.Where(`"users"."isBotAdmin" = ?`, *opts.IsBotAdmin.Value())
	}

	if opts.IsBanned.IsSet() {
		query = query.Where(`"users"."is_banned" = ?`, *opts.IsBanned.Value())
	}

	if len(opts.Badges.Value()) != 0 {
		query = query.
			Joins("LEFT JOIN badges_users ON badges_users.user_id = users.id").
			Where(`badges_users.badge_id IN (?)`, opts.Badges.Value())
	}

	var total int64
	if err := query.Model(&model.Users{}).Count(&total).Error; err != nil {
		return nil, err
	}

	var dbUsers []model.Users
	if err := query.
		Limit(perPage).
		Offset(page * perPage).
		Find(&dbUsers).Error; err != nil {
		return nil, err
	}

	mappedUsers := make([]gqlmodel.TwirUser, 0, len(dbUsers))

	dbUsersIds := make([]string, 0, len(dbUsers))
	for _, user := range dbUsers {
		dbUsersIds = append(dbUsersIds, user.ID)
	}

	twitchUsers, err := r.cachedTwitchClient.GetUsersByIds(ctx, dbUsersIds)
	if err != nil {
		return nil, err
	}

	for _, user := range dbUsers {
		u := gqlmodel.TwirUser{
			ID:         user.ID,
			IsBotAdmin: user.IsBotAdmin,
			IsBanned:   user.IsBanned,
			TwitchInfo: &gqlmodel.TwirUserTwitchInfo{},
		}

		if user.Channel != nil {
			u.IsBotEnabled = user.Channel.IsEnabled
		}

		twitchUser, found := lo.Find(
			twitchUsers, func(item twitchcahe.TwitchUser) bool {
				return item.ID == u.ID
			},
		)

		if found {
			u.TwitchInfo.Login = twitchUser.Login
			u.TwitchInfo.DisplayName = twitchUser.DisplayName
			u.TwitchInfo.ProfileImageURL = twitchUser.ProfileImageURL
		}

		mappedUsers = append(mappedUsers, u)
	}

	return &gqlmodel.TwirUsersResponse{
		Users: mappedUsers,
		Total: int(total),
	}, nil
}
