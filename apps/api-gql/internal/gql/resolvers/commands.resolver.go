package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	model "github.com/satont/twir/libs/gomodels"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/graph"
)

// Responses is the resolver for the responses field.
func (r *commandResolver) Responses(
	ctx context.Context,
	obj *gqlmodel.Command,
) ([]gqlmodel.CommandResponse, error) {
	if obj.Default {
		return []gqlmodel.CommandResponse{}, nil
	}

	var responses []model.ChannelsCommandsResponses
	if err := r.gorm.
		WithContext(ctx).
		Where(`"commandId" = ?`, obj.ID).
		Find(&responses).Error; err != nil {
		return nil, err
	}

	convertedResponses := make([]gqlmodel.CommandResponse, len(responses))
	for i, response := range responses {
		convertedResponses[i] = gqlmodel.CommandResponse{
			ID:        response.ID,
			CommandID: response.CommandID,
			Text:      response.Text.String,
			Order:     response.Order,
		}
	}

	return convertedResponses, nil
}

// CreateCommand is the resolver for the createCommand field.
func (r *mutationResolver) CreateCommand(
	ctx context.Context,
	opts gqlmodel.CreateCommandInput,
) (*gqlmodel.Command, error) {
	user, err := r.sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return nil, err
	}

	if r.clientsCommandsChannels[user.ID] != nil {
		r.clientsCommandsChannels[user.ID] <- &gqlmodel.Command{
			ID: uuid.NewString(),
		}
	}

	return &gqlmodel.Command{
		ID: uuid.NewString(),
	}, nil
}

// UpdateCommand is the resolver for the updateCommand field.
func (r *mutationResolver) UpdateCommand(
	ctx context.Context,
	id string,
	opts gqlmodel.UpdateCommandOpts,
) (*gqlmodel.Command, error) {
	return nil, fmt.Errorf("not implemented")
}

// Commands is the resolver for the commands field.
func (r *queryResolver) Commands(ctx context.Context) ([]gqlmodel.Command, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	var entities []model.ChannelsCommands
	if err := r.gorm.
		WithContext(ctx).
		Where(`"channelId" = ?`, dashboardId).
		Find(&entities).Error; err != nil {
		return nil, err
	}

	convertedCommands := make([]gqlmodel.Command, len(entities))
	for i, entity := range entities {
		cooldown := entity.Cooldown.Int64
		cooldownInt := int(cooldown)

		convertedCommands[i] = gqlmodel.Command{
			ID:                        entity.ID,
			Name:                      entity.Name,
			Description:               entity.Description.Ptr(),
			Aliases:                   entity.Aliases,
			Cooldown:                  &cooldownInt,
			CooldownType:              entity.CooldownType,
			Enabled:                   entity.Enabled,
			Visible:                   entity.Visible,
			Default:                   entity.Default,
			DefaultName:               entity.DefaultName.Ptr(),
			Module:                    entity.Module,
			IsReply:                   entity.IsReply,
			KeepResponsesOrder:        entity.KeepResponsesOrder,
			DeniedUsersIds:            entity.DeniedUsersIDS,
			AllowedUsersIds:           entity.AllowedUsersIDS,
			RolesIds:                  entity.RolesIDS,
			OnlineOnly:                entity.OnlineOnly,
			CooldownRolesIds:          entity.CooldownRolesIDs,
			EnabledCategories:         entity.EnabledCategories,
			RequiredWatchTime:         entity.RequiredWatchTime,
			RequiredMessages:          entity.RequiredMessages,
			RequiredUsedChannelPoints: entity.RequiredUsedChannelPoints,
		}
	}
	return convertedCommands, nil
}

// Command returns graph.CommandResolver implementation.
func (r *Resolver) Command() graph.CommandResolver { return &commandResolver{r} }

type commandResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *subscriptionResolver) NewCommand(ctx context.Context) (<-chan *gqlmodel.Command, error) {
	subChan := make(chan *gqlmodel.Command, 1)

	user, err := r.sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return nil, err
	}

	if r.clientsCommandsChannels[user.ID] == nil {
		r.clientsCommandsChannels[user.ID] = make(chan *gqlmodel.Command)
	}

	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case cmd := <-r.clientsCommandsChannels[user.ID]:
				subChan <- cmd
			}
		}
	}()

	return subChan, nil
}
