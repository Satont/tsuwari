package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"strings"

	"github.com/google/uuid"
	"github.com/guregu/null"
	"github.com/samber/lo"
	model "github.com/satont/twir/libs/gomodels"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/graph"
	"gorm.io/gorm"
)

// Responses is the resolver for the responses field.
func (r *commandResolver) Responses(
	ctx context.Context,
	obj *gqlmodel.Command,
) ([]gqlmodel.CommandResponse, error) {
	if obj.Default {
		return []gqlmodel.CommandResponse{}, nil
	}

	var responses []model.ChannelsCommandsResponses
	if err := r.gorm.
		WithContext(ctx).
		Where(`"commandId" = ?`, obj.ID).
		Find(&responses).Error; err != nil {
		return nil, err
	}

	convertedResponses := make([]gqlmodel.CommandResponse, 0, len(responses))
	for _, response := range responses {
		convertedResponses = append(
			convertedResponses,
			gqlmodel.CommandResponse{
				ID:        response.ID,
				CommandID: response.CommandID,
				Text:      response.Text.String,
				Order:     response.Order,
			},
		)
	}

	return convertedResponses, nil
}

// CommandsCreate is the resolver for the commandsCreate field.
func (r *mutationResolver) CommandsCreate(
	ctx context.Context,
	opts gqlmodel.CommandsCreateOrUpdateOpts,
) (bool, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	command := &model.ChannelsCommands{
		ID:           uuid.New().String(),
		Name:         strings.ToLower(opts.Name),
		Cooldown:     null.IntFrom(int64(opts.Cooldown)),
		CooldownType: opts.CooldownType,
		Enabled:      opts.Enabled,
		Aliases: lo.Map(
			lo.IfF(
				opts.Aliases == nil, func() []string {
					return []string{}
				},
			).Else(opts.Aliases),
			func(alias string, _ int) string {
				return strings.TrimSuffix(strings.ToLower(alias), "!")
			},
		),
		Description:               null.StringFrom(opts.Description),
		Visible:                   opts.Visible,
		ChannelID:                 dashboardId,
		Default:                   false,
		DefaultName:               null.String{},
		Module:                    "CUSTOM",
		IsReply:                   opts.IsReply,
		KeepResponsesOrder:        opts.KeepResponsesOrder,
		DeniedUsersIDS:            opts.DeniedUsersIds,
		AllowedUsersIDS:           opts.AllowedUsersIds,
		RolesIDS:                  opts.RolesIds,
		OnlineOnly:                opts.OnlineOnly,
		RequiredWatchTime:         opts.RequiredWatchTime,
		RequiredMessages:          opts.RequiredMessages,
		RequiredUsedChannelPoints: opts.RequiredUsedChannelPoints,
		Responses: make(
			[]*model.ChannelsCommandsResponses,
			0,
			len(opts.Responses),
		),
		GroupID:           null.StringFromPtr(opts.GroupID.Value()),
		CooldownRolesIDs:  opts.CooldownRolesIds,
		EnabledCategories: opts.EnabledCategories,
	}

	for _, res := range opts.Responses {
		if res.Text == "" {
			continue
		}

		command.Responses = append(
			command.Responses, &model.ChannelsCommandsResponses{
				ID:    uuid.New().String(),
				Text:  null.StringFrom(res.Text),
				Order: res.Order,
			},
		)
	}

	err = r.gorm.WithContext(ctx).Create(command).Error
	if err != nil {
		return false, err
	}

	return true, nil
}

// CommandsUpdate is the resolver for the commandsUpdate field.
func (r *mutationResolver) CommandsUpdate(
	ctx context.Context,
	id string,
	opts gqlmodel.CommandsCreateOrUpdateOpts,
) (bool, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	cmd := &model.ChannelsCommands{}
	if err := r.gorm.
		WithContext(ctx).
		Where(
			`"id" = ? AND "channelId" = ?`, id, dashboardId,
		).
		First(cmd).
		Error; err != nil {
		return false, err
	}

	cmd.Name = strings.ToLower(opts.Name)
	cmd.Cooldown = null.IntFrom(int64(opts.Cooldown))
	cmd.CooldownType = opts.CooldownType
	cmd.Enabled = opts.Enabled
	cmd.Aliases = lo.Map(
		lo.IfF(
			opts.Aliases == nil, func() []string {
				return []string{}
			},
		).Else(opts.Aliases),
		func(alias string, _ int) string {
			return strings.TrimSuffix(strings.ToLower(alias), "!")
		},
	)
	cmd.Description = null.StringFrom(opts.Description)
	cmd.Visible = opts.Visible
	cmd.IsReply = opts.IsReply
	cmd.KeepResponsesOrder = opts.KeepResponsesOrder
	cmd.AllowedUsersIDS = lo.IfF(
		opts.AllowedUsersIds == nil, func() []string {
			return []string{}
		},
	).Else(opts.AllowedUsersIds)
	cmd.DeniedUsersIDS = lo.IfF(
		opts.DeniedUsersIds == nil, func() []string {
			return []string{}
		},
	).Else(opts.DeniedUsersIds)
	cmd.RolesIDS = lo.IfF(
		opts.RolesIds == nil, func() []string {
			return []string{}
		},
	).Else(opts.RolesIds)
	cmd.OnlineOnly = opts.OnlineOnly
	cmd.RequiredWatchTime = opts.RequiredWatchTime
	cmd.RequiredMessages = opts.RequiredMessages
	cmd.RequiredUsedChannelPoints = opts.RequiredUsedChannelPoints
	cmd.GroupID = null.StringFromPtr(opts.GroupID.Value())
	cmd.Responses = make([]*model.ChannelsCommandsResponses, 0, len(opts.Responses))
	cmd.CooldownRolesIDs = lo.IfF(
		opts.CooldownRolesIds == nil, func() []string {
			return []string{}
		},
	).Else(opts.CooldownRolesIds)
	cmd.EnabledCategories = lo.IfF(
		opts.EnabledCategories == nil, func() []string {
			return []string{}
		},
	).Else(opts.EnabledCategories)

	for _, res := range opts.Responses {
		if res.Text == "" {
			continue
		}

		response := &model.ChannelsCommandsResponses{
			Text:      null.StringFrom(res.Text),
			Order:     res.Order,
			CommandID: cmd.ID,
		}

		cmd.Responses = append(cmd.Responses, response)
	}

	txErr := r.gorm.
		WithContext(ctx).
		Transaction(
			func(tx *gorm.DB) error {
				if err = tx.Delete(
					&model.ChannelsCommandsResponses{},
					`"commandId" = ?`,
					cmd.ID,
				).Error; err != nil {
					return err
				}

				return tx.Save(cmd).Error
			},
		)
	if txErr != nil {
		return false, err
	}

	return true, nil
}

// CommandsRemove is the resolver for the commandsRemove field.
func (r *mutationResolver) CommandsRemove(ctx context.Context, id string) (bool, error) {
	cmd := &model.ChannelsCommands{}

	if err := r.gorm.
		WithContext(ctx).
		Where(`"id" = ?`, id).
		First(cmd).
		Error; err != nil {
		return false, err
	}

	if cmd.Default {
		return false, fmt.Errorf("cannot remove default command")
	}

	if err := r.gorm.WithContext(ctx).Delete(&cmd).Error; err != nil {
		return false, err
	}

	return true, nil
}

// Commands is the resolver for the commands field.
func (r *queryResolver) Commands(ctx context.Context) ([]gqlmodel.Command, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	var entities []model.ChannelsCommands
	if err := r.gorm.
		WithContext(ctx).
		Where(`"channelId" = ?`, dashboardId).
		Order("name ASC").
		Find(&entities).Error; err != nil {
		return nil, err
	}

	convertedCommands := make([]gqlmodel.Command, 0, len(entities))
	for _, entity := range entities {
		cooldown := entity.Cooldown.Int64
		cooldownInt := int(cooldown)

		convertedCommands = append(
			convertedCommands,
			gqlmodel.Command{
				ID:                        entity.ID,
				Name:                      entity.Name,
				Description:               entity.Description.Ptr(),
				Aliases:                   entity.Aliases,
				Cooldown:                  &cooldownInt,
				CooldownType:              entity.CooldownType,
				Enabled:                   entity.Enabled,
				Visible:                   entity.Visible,
				Default:                   entity.Default,
				DefaultName:               entity.DefaultName.Ptr(),
				Module:                    entity.Module,
				IsReply:                   entity.IsReply,
				KeepResponsesOrder:        entity.KeepResponsesOrder,
				DeniedUsersIds:            entity.DeniedUsersIDS,
				AllowedUsersIds:           entity.AllowedUsersIDS,
				RolesIds:                  entity.RolesIDS,
				OnlineOnly:                entity.OnlineOnly,
				CooldownRolesIds:          entity.CooldownRolesIDs,
				EnabledCategories:         entity.EnabledCategories,
				RequiredWatchTime:         entity.RequiredWatchTime,
				RequiredMessages:          entity.RequiredMessages,
				RequiredUsedChannelPoints: entity.RequiredUsedChannelPoints,
			},
		)
	}
	return convertedCommands, nil
}

// Command returns graph.CommandResolver implementation.
func (r *Resolver) Command() graph.CommandResolver { return &commandResolver{r} }

type commandResolver struct{ *Resolver }
