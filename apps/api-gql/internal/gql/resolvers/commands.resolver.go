package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/guregu/null"
	"github.com/samber/lo"
	model "github.com/satont/twir/libs/gomodels"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/graph"
)

// Responses is the resolver for the responses field.
func (r *commandResolver) Responses(ctx context.Context, obj *gqlmodel.Command) ([]gqlmodel.CommandResponse, error) {
	if obj.Default {
		return []gqlmodel.CommandResponse{}, nil
	}

	var responses []model.ChannelsCommandsResponses
	if err := r.gorm.
		WithContext(ctx).
		Where(`"commandId" = ?`, obj.ID).
		Find(&responses).Error; err != nil {
		return nil, err
	}

	convertedResponses := make([]gqlmodel.CommandResponse, len(responses))
	for i, response := range responses {
		convertedResponses[i] = gqlmodel.CommandResponse{
			ID:        response.ID,
			CommandID: response.CommandID,
			Text:      response.Text.String,
			Order:     response.Order,
		}
	}

	return convertedResponses, nil
}

// CreateCommand is the resolver for the createCommand field.
func (r *mutationResolver) CreateCommand(ctx context.Context, opts gqlmodel.CreateCommandInput) (*gqlmodel.Command, error) {
	_, err := r.sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return nil, err
	}

	return &gqlmodel.Command{
		ID: uuid.NewString(),
	}, nil
}

// UpdateCommand is the resolver for the updateCommand field.
func (r *mutationResolver) UpdateCommand(ctx context.Context, id string, opts gqlmodel.UpdateCommandOpts) (*gqlmodel.Command, error) {
	cmd := &model.ChannelsCommands{}
	if err := r.gorm.WithContext(ctx).Where(`"id" = ?`, id).First(cmd).Error; err != nil {
		return nil, err
	}

	if opts.Name.IsSet() {
		cmd.Name = lo.FromPtr(opts.Name.Value())
	}

	if opts.Description.IsSet() {
		cmd.Description = null.StringFromPtr(opts.Description.Value())
	}

	if opts.Aliases.IsSet() {
		cmd.Aliases = opts.Aliases.Value()
	}

	if opts.Cooldown.IsSet() {
		value := lo.FromPtr(opts.Cooldown.Value())
		cmd.Cooldown = null.IntFrom(int64(value))
	}

	if opts.CooldownType.IsSet() {
		cmd.CooldownType = lo.FromPtr(opts.CooldownType.Value())
	}

	if opts.Enabled.IsSet() {
		cmd.Enabled = lo.FromPtr(opts.Enabled.Value())
	}

	if opts.Visible.IsSet() {
		cmd.Visible = lo.FromPtr(opts.Visible.Value())
	}

	if opts.Visible.IsSet() {
		cmd.Visible = lo.FromPtr(opts.Visible.Value())
	}

	if opts.IsReply.IsSet() {
		cmd.IsReply = lo.FromPtr(opts.IsReply.Value())
	}

	if opts.KeepResponsesOrder.IsSet() {
		cmd.KeepResponsesOrder = lo.FromPtr(opts.KeepResponsesOrder.Value())
	}

	if opts.DeniedUsersIds.IsSet() {
		cmd.DeniedUsersIDS = opts.DeniedUsersIds.Value()
	}

	if opts.AllowedUsersIds.IsSet() {
		cmd.AllowedUsersIDS = opts.AllowedUsersIds.Value()
	}

	if opts.RolesIds.IsSet() {
		cmd.RolesIDS = opts.RolesIds.Value()
	}

	if opts.OnlineOnly.IsSet() {
		cmd.OnlineOnly = lo.FromPtr(opts.OnlineOnly.Value())

	}

	if opts.CooldownRolesIds.IsSet() {
		cmd.CooldownRolesIDs = opts.CooldownRolesIds.Value()
	}

	if opts.EnabledCategories.IsSet() {
		cmd.EnabledCategories = opts.EnabledCategories.Value()
	}

	if opts.RequiredWatchTime.IsSet() {
		cmd.RequiredWatchTime = lo.FromPtr(opts.RequiredWatchTime.Value())
	}

	if opts.RequiredMessages.IsSet() {
		cmd.RequiredMessages = lo.FromPtr(opts.RequiredMessages.Value())
	}

	if opts.RequiredUsedChannelPoints.IsSet() {
		cmd.RequiredUsedChannelPoints = lo.FromPtr(opts.RequiredUsedChannelPoints.Value())
	}

	if opts.Responses.IsSet() {
		// TODO
	}

	if err := r.gorm.WithContext(ctx).Save(cmd).Error; err != nil {
		return nil, err
	}

	// TODO
	return nil, nil
}

// RemoveCommand is the resolver for the removeCommand field.
func (r *mutationResolver) RemoveCommand(ctx context.Context, id string) (bool, error) {
	cmd := &model.ChannelsCommands{}
	if err := r.gorm.WithContext(ctx).Where(`"id" = ?`, id).First(cmd).Error; err != nil {
		return false, err
	}

	if cmd.Default {
		return false, fmt.Errorf("cannot remove default command")
	}

	if err := r.gorm.WithContext(ctx).Delete(&cmd).Error; err != nil {
		return false, err
	}

	return true, nil
}

// Commands is the resolver for the commands field.
func (r *queryResolver) Commands(ctx context.Context) ([]gqlmodel.Command, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	var entities []model.ChannelsCommands
	if err := r.gorm.
		WithContext(ctx).
		Where(`"channelId" = ?`, dashboardId).
		Find(&entities).Error; err != nil {
		return nil, err
	}

	convertedCommands := make([]gqlmodel.Command, len(entities))
	for i, entity := range entities {
		cooldown := entity.Cooldown.Int64
		cooldownInt := int(cooldown)

		convertedCommands[i] = gqlmodel.Command{
			ID:                        entity.ID,
			Name:                      entity.Name,
			Description:               entity.Description.Ptr(),
			Aliases:                   entity.Aliases,
			Cooldown:                  &cooldownInt,
			CooldownType:              entity.CooldownType,
			Enabled:                   entity.Enabled,
			Visible:                   entity.Visible,
			Default:                   entity.Default,
			DefaultName:               entity.DefaultName.Ptr(),
			Module:                    entity.Module,
			IsReply:                   entity.IsReply,
			KeepResponsesOrder:        entity.KeepResponsesOrder,
			DeniedUsersIds:            entity.DeniedUsersIDS,
			AllowedUsersIds:           entity.AllowedUsersIDS,
			RolesIds:                  entity.RolesIDS,
			OnlineOnly:                entity.OnlineOnly,
			CooldownRolesIds:          entity.CooldownRolesIDs,
			EnabledCategories:         entity.EnabledCategories,
			RequiredWatchTime:         entity.RequiredWatchTime,
			RequiredMessages:          entity.RequiredMessages,
			RequiredUsedChannelPoints: entity.RequiredUsedChannelPoints,
		}
	}
	return convertedCommands, nil
}

// Command returns graph.CommandResolver implementation.
func (r *Resolver) Command() graph.CommandResolver { return &commandResolver{r} }

type commandResolver struct{ *Resolver }
