package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	model "github.com/satont/twir/libs/gomodels"
	data_loader "github.com/twirapp/twir/apps/api-gql/internal/gql/data-loader"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/gql/graph"
)

// TwitchProfile is the resolver for the twitchProfile field.
func (r *emoteStatisticUserUsageResolver) TwitchProfile(
	ctx context.Context,
	obj *gqlmodel.EmoteStatisticUserUsage,
) (*gqlmodel.TwirUserTwitchInfo, error) {
	return data_loader.GetHelixUserById(ctx, obj.UserID)
}

// EmotesStatistics is the resolver for the emotesStatistics field.
func (r *queryResolver) EmotesStatistics(
	ctx context.Context,
	opts gqlmodel.EmotesStatisticsOpts,
) (*gqlmodel.EmotesStatisticResponse, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	var page int
	perPage := 10

	if opts.Page.IsSet() {
		page = *opts.Page.Value()
	}

	if opts.PerPage.IsSet() {
		perPage = *opts.PerPage.Value()
	}

	query := r.gorm.WithContext(ctx).
		Where(`"channelId" = ?`, dashboardId).
		Limit(perPage).
		Offset(page * perPage)

	if opts.Search.IsSet() && *opts.Search.Value() != "" {
		query = query.Where(`"emote" LIKE ?`, "%"+*opts.Search.Value()+"%")
	}

	var order gqlmodel.EmotesStatisticsOptsOrder
	if opts.Order.IsSet() {
		order = *opts.Order.Value()
	} else {
		order = gqlmodel.EmotesStatisticsOptsOrderDesc
	}

	var entities []emoteEntityModelWithCount
	if err :=
		query.
			Select(`"emote", COUNT(emote) as count`).
			Group("emote").
			Order(fmt.Sprintf("count %s", order.String())).
			Find(&entities).
			Error; err != nil {
		return nil, err
	}

	var totalCount int64
	if err := r.gorm.
		WithContext(ctx).
		Raw(
			`
				SELECT COUNT(DISTINCT emote)
				FROM channels_emotes_usages
				WHERE "channelId" = ?
				`,
			dashboardId,
		).
		Scan(&totalCount).Error; err != nil {
		return nil, fmt.Errorf("failed to get total count: %w", err)
	}

	models := make([]gqlmodel.EmotesStatistic, 0, len(entities))
	for _, entity := range entities {
		lastUsedEntity := &model.ChannelEmoteUsage{}
		if err := r.gorm.
			WithContext(ctx).
			Where(`"channelId" = ? AND "emote" = ?`, dashboardId, entity.Emote).
			Order(`"createdAt" DESC`).
			First(lastUsedEntity).Error; err != nil {
			return nil, err
		}

		var rangeType gqlmodel.EmoteStatisticRange
		if opts.GraphicRange.IsSet() {
			rangeType = *opts.GraphicRange.Value()
		} else {
			rangeType = gqlmodel.EmoteStatisticRangeLastDay
		}

		graphicUsages, err := r.getEmoteStatisticUsagesForRange(
			ctx,
			entity.Emote,
			rangeType,
		)
		if err != nil {
			return nil, err
		}

		models = append(
			models, gqlmodel.EmotesStatistic{
				EmoteName:         entity.Emote,
				TotalUsages:       entity.Count,
				LastUsedTimestamp: int(lastUsedEntity.CreatedAt.UTC().UnixMilli()),
				GraphicUsages:     graphicUsages,
			},
		)
	}

	return &gqlmodel.EmotesStatisticResponse{
		Emotes: models,
		Total:  int(totalCount),
	}, nil
}

// EmotesStatisticEmoteDetailedInformation is the resolver for the emotesStatisticEmoteDetailedInformation field.
func (r *queryResolver) EmotesStatisticEmoteDetailedInformation(
	ctx context.Context,
	opts gqlmodel.EmotesStatisticEmoteDetailedOpts,
) (*gqlmodel.EmotesStatisticEmoteDetailedResponse, error) {
	if opts.EmoteName == "" {
		return nil, nil
	}

	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	graphicUsages, err := r.getEmoteStatisticUsagesForRange(ctx, opts.EmoteName, opts.Range)
	if err != nil {
		return nil, err
	}

	lastUsedEntity := &model.ChannelEmoteUsage{}
	if err := r.gorm.
		WithContext(ctx).
		Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
		Order(`"createdAt" DESC`).
		First(lastUsedEntity).Error; err != nil {
		return nil, err
	}

	var usages int64
	if err := r.gorm.
		WithContext(ctx).
		Model(&model.ChannelEmoteUsage{}).
		Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
		Count(&usages).Error; err != nil {
		return nil, err
	}

	var usagedByUserPage int
	usagesByUserPerPage := 10

	if opts.UsagesByUsersPage.IsSet() {
		usagedByUserPage = *opts.UsagesByUsersPage.Value()
	}

	if opts.UsagesByUsersPerPage.IsSet() {
		usagesByUserPerPage = *opts.UsagesByUsersPerPage.Value()
	}

	var usagesByUsers []model.ChannelEmoteUsage
	if err := r.gorm.
		WithContext(ctx).
		Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
		Limit(usagesByUserPerPage).
		Offset(usagedByUserPage * usagesByUserPerPage).
		Find(&usagesByUsers).Error; err != nil {
		return nil, err
	}

	var usagesByUsersTotalCount int64
	if err := r.gorm.
		WithContext(ctx).
		Model(&model.ChannelEmoteUsage{}).
		Where(`"channelId" = ? AND "emote" = ?`, dashboardId, opts.EmoteName).
		Count(&usagesByUsersTotalCount).Error; err != nil {
		return nil, err
	}

	users := make([]gqlmodel.EmoteStatisticUserUsage, 0, len(usagesByUsers))
	for _, usage := range usagesByUsers {
		users = append(
			users, gqlmodel.EmoteStatisticUserUsage{
				UserID: usage.UserID,
				Date:   usage.CreatedAt,
			},
		)
	}

	return &gqlmodel.EmotesStatisticEmoteDetailedResponse{
		EmoteName:          opts.EmoteName,
		TotalUsages:        int(usages),
		LastUsedTimestamp:  int(lastUsedEntity.CreatedAt.UTC().UnixMilli()),
		GraphicUsages:      graphicUsages,
		UsagesByUsers:      users,
		UsagesByUsersTotal: int(usagesByUsersTotalCount),
	}, nil
}

// EmoteStatisticUserUsage returns graph.EmoteStatisticUserUsageResolver implementation.
func (r *Resolver) EmoteStatisticUserUsage() graph.EmoteStatisticUserUsageResolver {
	return &emoteStatisticUserUsageResolver{r}
}

type emoteStatisticUserUsageResolver struct{ *Resolver }
