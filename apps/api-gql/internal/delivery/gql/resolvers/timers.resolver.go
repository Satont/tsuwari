package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"

	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/services/timers"
)

// TimersCreate is the resolver for the timersCreate field.
func (r *mutationResolver) TimersCreate(ctx context.Context, opts gqlmodel.TimerCreateInput) (*gqlmodel.Timer, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return nil, err
	}

	responses := make([]timers.CreateResponse, 0, len(opts.Responses))
	for _, response := range opts.Responses {
		responses = append(
			responses,
			timers.CreateResponse{
				Text:       response.Text,
				IsAnnounce: response.IsAnnounce,
			},
		)
	}
	timer, err := r.timersService.Create(
		ctx, timers.CreateInput{
			ChannelID:       dashboardId,
			ActorID:         user.ID,
			Name:            opts.Name,
			Enabled:         opts.Enabled,
			TimeInterval:    opts.TimeInterval,
			MessageInterval: opts.MessageInterval,
			Responses:       responses,
		},
	)

	converted := mappers.TimerEntityToGql(timer)
	return &converted, nil
}

// TimersUpdate is the resolver for the timersUpdate field.
func (r *mutationResolver) TimersUpdate(ctx context.Context, id string, opts gqlmodel.TimerUpdateInput) (*gqlmodel.Timer, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	user, err := r.sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return nil, err
	}

	responses := make([]timers.CreateResponse, 0, len(opts.Responses.Value()))
	for _, response := range opts.Responses.Value() {
		responses = append(
			responses,
			timers.CreateResponse{
				Text:       response.Text,
				IsAnnounce: response.IsAnnounce,
			},
		)
	}

	timer, err := r.timersService.Update(
		ctx,
		timers.UpdateInput{
			ChannelID:       dashboardId,
			ActorID:         user.ID,
			ID:              id,
			Name:            opts.Name.Value(),
			Enabled:         opts.Enabled.Value(),
			TimeInterval:    opts.TimeInterval.Value(),
			MessageInterval: opts.MessageInterval.Value(),
			Responses:       responses,
		},
	)
	if err != nil {
		return nil, err
	}

	converted := mappers.TimerEntityToGql(timer)
	return &converted, nil
}

// TimersRemove is the resolver for the timersRemove field.
func (r *mutationResolver) TimersRemove(ctx context.Context, id string) (bool, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return false, err
	}

	user, err := r.sessions.GetAuthenticatedUser(ctx)
	if err != nil {
		return false, err
	}

	err = r.timersService.Delete(ctx, id, dashboardId, user.ID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// Timers is the resolver for the timers field.
func (r *queryResolver) Timers(ctx context.Context) ([]gqlmodel.Timer, error) {
	dashboardId, err := r.sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	channelTimers, err := r.timersService.GetAllByChannelID(ctx, dashboardId)
	if err != nil {
		return nil, err
	}

	converted := make([]gqlmodel.Timer, 0, len(channelTimers))
	for _, timer := range channelTimers {
		converted = append(converted, mappers.TimerEntityToGql(timer))
	}

	return converted, nil
}
