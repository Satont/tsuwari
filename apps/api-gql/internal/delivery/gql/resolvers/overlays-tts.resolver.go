package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"bytes"
	"context"
	"fmt"
	"net/url"

	"github.com/goccy/go-json"
	"github.com/google/uuid"
	req "github.com/imroc/req/v3"
	"github.com/samber/lo"
	model "github.com/satont/twir/libs/gomodels"
	"github.com/satont/twir/libs/types/types/api/modules"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/mappers"
	"github.com/twirapp/twir/apps/api-gql/internal/server"
)

// OverlaysTTSUpdate is the resolver for the overlaysTTSUpdate field.
func (r *mutationResolver) OverlaysTTSUpdate(ctx context.Context, input gqlmodel.OverlaysTTSInput) (*gqlmodel.OverlaysTTSOutput, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	entity := &model.ChannelModulesSettings{}
	if err := r.deps.Gorm.
		WithContext(ctx).
		Where(`"channelId" = ? AND "type" = ? AND "userId" IS NULL`, dashboardID, "tts").
		Find(entity).Error; err != nil {
		return nil, err
	}

	settings := &modules.TTSSettings{
		Enabled:                            &input.Enabled,
		Rate:                               input.Rate,
		Volume:                             input.Volume,
		Pitch:                              input.Pitch,
		Voice:                              input.Voice,
		AllowUsersChooseVoiceInMainCommand: input.AllowUsersChooseVoiceInMainCommand,
		MaxSymbols:                         input.MaxSymbols,
		DisallowedVoices:                   input.DisallowedVoices,
		DoNotReadEmoji:                     input.DoNotReadEmoji,
		DoNotReadTwitchEmotes:              input.DoNotReadTwitchEmotes,
		DoNotReadLinks:                     input.DoNotReadLinks,
		ReadChatMessages:                   input.ReadChatMessages,
		ReadChatMessagesNicknames:          input.ReadChatMessagesNicknames,
	}
	bytes, err := json.Marshal(settings)
	if err != nil {
		return nil, err
	}

	if entity.ID == "" {
		entity.ID = uuid.New().String()
		entity.ChannelId = dashboardID
		entity.Type = "tts"
	}

	entity.Settings = bytes
	if err := r.deps.Gorm.WithContext(ctx).Save(entity).Error; err != nil {
		return nil, err
	}

	return &gqlmodel.OverlaysTTSOutput{
		Enabled:                            lo.FromPtr(settings.Enabled),
		Rate:                               settings.Rate,
		Volume:                             settings.Volume,
		Pitch:                              settings.Pitch,
		Voice:                              settings.Voice,
		AllowUsersChooseVoiceInMainCommand: settings.AllowUsersChooseVoiceInMainCommand,
		MaxSymbols:                         settings.MaxSymbols,
		DisallowedVoices:                   settings.DisallowedVoices,
		DoNotReadEmoji:                     settings.DoNotReadEmoji,
		DoNotReadTwitchEmotes:              settings.DoNotReadTwitchEmotes,
		DoNotReadLinks:                     settings.DoNotReadLinks,
		ReadChatMessages:                   settings.ReadChatMessages,
		ReadChatMessagesNicknames:          settings.ReadChatMessagesNicknames,
	}, nil
}

// OverlaysTts is the resolver for the overlaysTTS field.
func (r *queryResolver) OverlaysTts(ctx context.Context) (*gqlmodel.OverlaysTTSOutput, error) {
	dashboardID, err := r.deps.Sessions.GetSelectedDashboard(ctx)
	if err != nil {
		return nil, err
	}

	entity := &model.ChannelModulesSettings{}
	if err := r.deps.Gorm.
		WithContext(ctx).
		Where(`"channelId" = ? AND "type" = ? AND "userId" IS null`, dashboardID, "tts").
		First(entity).Error; err != nil {
		return nil, fmt.Errorf("settings not found: %w", err)
	}

	settings := &modules.TTSSettings{}
	if err := json.Unmarshal(entity.Settings, settings); err != nil {
		return nil, fmt.Errorf("cannot parse tts settings: %w", err)
	}

	return &gqlmodel.OverlaysTTSOutput{
		Enabled:                            lo.FromPtr(settings.Enabled),
		Rate:                               settings.Rate,
		Volume:                             settings.Volume,
		Pitch:                              settings.Pitch,
		Voice:                              settings.Voice,
		AllowUsersChooseVoiceInMainCommand: settings.AllowUsersChooseVoiceInMainCommand,
		MaxSymbols:                         settings.MaxSymbols,
		DisallowedVoices:                   settings.DisallowedVoices,
		DoNotReadEmoji:                     settings.DoNotReadEmoji,
		DoNotReadTwitchEmotes:              settings.DoNotReadTwitchEmotes,
		DoNotReadLinks:                     settings.DoNotReadLinks,
		ReadChatMessages:                   settings.ReadChatMessages,
		ReadChatMessagesNicknames:          settings.ReadChatMessagesNicknames,
	}, nil
}

// OverlaysTTSVoices is the resolver for the overlaysTTSVoices field.
func (r *queryResolver) OverlaysTTSVoices(ctx context.Context) (*gqlmodel.OverlaysTTSVoices, error) {
	rhVoices := r.deps.TTSVoicesService.GetRHVoices()
	mappedRhVoices := make([]gqlmodel.RHVoice, 0, len(rhVoices))
	for _, v := range rhVoices {
		mappedRhVoices = append(mappedRhVoices, mappers.RHVoiceTo(v))
	}

	return &gqlmodel.OverlaysTTSVoices{
		Rhvoices: mappedRhVoices,
	}, nil
}

// OverlaysTTSSay is the resolver for the overlaysTTSSay field.
func (r *queryResolver) OverlaysTTSSay(ctx context.Context) ([]byte, error) {
	reqUrl, err := url.Parse(fmt.Sprintf("http://%s/say", r.deps.Config.TTSServiceUrl))
	if err != nil {
		return nil, err
	}

	query := reqUrl.Query()

	query.Set("voice", "anna")
	query.Set("pitch", "50")
	query.Set("volume", "30")
	query.Set("rate", "50")
	query.Set("text", "привет мир")

	reqUrl.RawQuery = query.Encode()

	var b bytes.Buffer
	resp, err := req.SetContext(ctx).SetOutput(&b).Get(reqUrl.String())
	if err != nil {
		return nil, fmt.Errorf("cannot use say %w", err)
	}
	if !resp.IsSuccessState() {
		return nil, fmt.Errorf("cannot use say %s", resp.String())
	}
	if err := server.SetHeader(ctx, "Content-Type", "audio/mp3"); err != nil {
		return nil, fmt.Errorf("cannot set header: %w", err)
	}

	return b.Bytes(), nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *mutationResolver) OverlaysTTSSay(ctx context.Context) ([]byte, error) {
	reqUrl, err := url.Parse(fmt.Sprintf("http://%s/say", r.deps.Config.TTSServiceUrl))
	if err != nil {
		return nil, err
	}

	query := reqUrl.Query()

	query.Set("voice", "anna")
	query.Set("pitch", "50")
	query.Set("volume", "30")
	query.Set("rate", "50")
	query.Set("text", "привет мир")

	reqUrl.RawQuery = query.Encode()

	var b bytes.Buffer
	resp, err := req.SetContext(ctx).SetOutput(&b).Get(reqUrl.String())
	if err != nil {
		return nil, fmt.Errorf("cannot use say %w", err)
	}
	if !resp.IsSuccessState() {
		return nil, fmt.Errorf("cannot use say %s", resp.String())
	}
	if err := server.SetHeader(ctx, "Content-Type", "audio/mp3"); err != nil {
		return nil, fmt.Errorf("cannot set header: %w", err)
	}

	return b.Bytes(), nil
}
