package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"log/slog"

	"github.com/nicklaw5/helix/v2"
	model "github.com/satont/twir/libs/gomodels"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/data-loader"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/gqlmodel"
	"github.com/twirapp/twir/apps/api-gql/internal/delivery/gql/graph"
	"github.com/twirapp/twir/apps/api-gql/internal/services/users"
)

// SwitchUserBan is the resolver for the switchUserBan field.
func (r *mutationResolver) SwitchUserBan(ctx context.Context, userID string) (bool, error) {
	user, err := r.usersService.GetByID(ctx, userID)
	if err != nil {
		r.logger.Error("failed to get user by id", slog.Any("err", err))
		return false, err
	}

	isBanned := !user.IsBanned

	_, err = r.usersService.Update(
		ctx,
		userID, users.UpdateInput{
			IsBanned: &isBanned,
		},
	)
	if err != nil {
		r.logger.Error("failed to update user", slog.Any("err", err))
		return false, err
	}

	return true, nil
}

// SwitchUserAdmin is the resolver for the switchUserAdmin field.
func (r *mutationResolver) SwitchUserAdmin(ctx context.Context, userID string) (bool, error) {
	user, err := r.usersService.GetByID(ctx, userID)
	if err != nil {
		r.logger.Error("failed to get user by id", slog.Any("err", err))
		return false, err
	}

	isBotAdmin := !user.IsBotAdmin

	_, err = r.usersService.Update(
		ctx,
		userID, users.UpdateInput{
			IsBotAdmin: &isBotAdmin,
		},
	)
	if err != nil {
		r.logger.Error("failed to update user", slog.Any("err", err))
		return false, err
	}

	return true, nil
}

// TwirUsers is the resolver for the twirUsers field.
func (r *queryResolver) TwirUsers(
	ctx context.Context,
	opts gqlmodel.TwirUsersSearchParams,
) (*gqlmodel.TwirUsersResponse, error) {
	var page int
	perPage := 20

	if opts.Page.IsSet() {
		page = *opts.Page.Value()
	}

	if opts.PerPage.IsSet() {
		perPage = *opts.PerPage.Value()
	}

	var foundTwitchChannels []helix.Channel
	if opts.Search.IsSet() {
		channels, err := r.cachedTwitchClient.SearchChannels(ctx, *opts.Search.Value())
		if err != nil {
			return nil, err
		}

		foundTwitchChannels = channels
	}

	query := r.gorm.
		WithContext(ctx).
		Order("id DESC").
		Joins("Channel")

	if len(foundTwitchChannels) > 0 {
		var ids []string
		for _, user := range foundTwitchChannels {
			ids = append(ids, user.ID)
		}

		query = query.Where(`"users"."id" IN ?`, ids)
	}

	if opts.IsBotEnabled.IsSet() {
		query = query.Where(`"Channel"."isEnabled" = ?`, *opts.IsBotEnabled.Value())
	}

	if opts.IsBotAdmin.IsSet() {
		query = query.Where(`"users"."isBotAdmin" = ?`, *opts.IsBotAdmin.Value())
	}

	if opts.IsBanned.IsSet() {
		query = query.Where(`"users"."is_banned" = ?`, *opts.IsBanned.Value())
	}

	if len(opts.Badges.Value()) != 0 {
		query = query.
			Joins("LEFT JOIN badges_users ON badges_users.user_id = users.id").
			Where(`badges_users.badge_id IN (?)`, opts.Badges.Value())
	}

	var total int64
	if err := query.Model(&model.Users{}).Count(&total).Error; err != nil {
		return nil, err
	}

	var dbUsers []model.Users
	if err := query.
		Limit(perPage).
		Offset(page * perPage).
		Find(&dbUsers).Error; err != nil {
		return nil, err
	}

	mappedUsers := make([]gqlmodel.TwirAdminUser, 0, len(dbUsers))

	dbUsersIds := make([]string, 0, len(dbUsers))
	for _, user := range dbUsers {
		dbUsersIds = append(dbUsersIds, user.ID)
	}

	for _, user := range dbUsers {
		u := gqlmodel.TwirAdminUser{
			ID:            user.ID,
			IsBotAdmin:    user.IsBotAdmin,
			IsBanned:      user.IsBanned,
			TwitchProfile: &gqlmodel.TwirUserTwitchInfo{},
			APIKey:        user.ApiKey,
		}

		if user.Channel != nil {
			u.IsBotEnabled = user.Channel.IsEnabled
		}

		mappedUsers = append(mappedUsers, u)
	}

	return &gqlmodel.TwirUsersResponse{
		Users: mappedUsers,
		Total: int(total),
	}, nil
}

// TwitchProfile is the resolver for the twitchProfile field.
func (r *twirAdminUserResolver) TwitchProfile(
	ctx context.Context,
	obj *gqlmodel.TwirAdminUser,
) (*gqlmodel.TwirUserTwitchInfo, error) {
	return data_loader.GetHelixUserById(ctx, obj.ID)
}

// TwirAdminUser returns graph.TwirAdminUserResolver implementation.
func (r *Resolver) TwirAdminUser() graph.TwirAdminUserResolver { return &twirAdminUserResolver{r} }

type twirAdminUserResolver struct{ *Resolver }
